#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
"""
Various utilities related to TPM based credential management.

"""

import logging
import os

from ironic_lib import utils
from oslo_utils import excutils

LOG = logging.getLogger(__name__)
DEFAULT_WORKDIR = "/tmp"
DEFAULT_POLICY_NAME = "trusted_policy.pol"
DEFAULT_POLICY_FILE = DEFAULT_WORKDIR + '/' + DEFAULT_POLICY_NAME
DEFAULT_PRIMARY_CTX_NAME = "primary.ctx"
DEFAULT_PRIMARY_CONTEXT = DEFAULT_WORKDIR + '/' + DEFAULT_PRIMARY_CTX_NAME
DEFAULT_SEALED_CTX_NAME = "key.ctx"
DEFAULT_SEALED_CONTEXT = DEFAULT_WORKDIR + '/' + DEFAULT_SEALED_CTX_NAME


def _generate_tpm_secret():
    """Generates a random string that will be sealed to TPM later.

    :returns: random secret generated by TPM
    :rtype: string
    """
    secret = ""
    try:
        secret = utils.execute('tpm2_getrandom', '--hex', '20')[0]
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERRPR: Failed to generate TPM secret")
    return secret


def _create_primary_tpm_context(primary_context=DEFAULT_PRIMARY_CONTEXT):
    """Creates the primary tpm context used for sealing a secret

    :returns: the path to the context file as string
    :rtype: string
    """
    try:
        utils.execute('tpm2_createprimary', '-p', 'secret', '-c',
                      primary_context)
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Failed to create TPM priamry context")
    return primary_context


def _make_primary_context_persistent(primary_context=DEFAULT_PRIMARY_CONTEXT):
    """Make the primary context persistent in the TPM chip

    """
    try:
        utils.execute('tpm2_evictcontrol', '-C', 'o', '-c',
                      primary_context, '0x81010001')
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Failed to make TPM priamry context persistent!")


def _create_tpm_policy(policy_file=DEFAULT_POLICY_FILE):
    """Creates the tpm policy for sealing secrets to tpm.

    :returns: the path to the policy file as a string
    :rtype: string
    """
    try:
        utils.execute('tpm2_createpolicy', '--policy-pcr', '-l', 'sha256:0',
                      '-L', policy_file)
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Failed to create trusted TPM policy")
    return policy_file


def _seal_secret_to_tpm(secret, context=DEFAULT_PRIMARY_CONTEXT,
                        policy=DEFAULT_POLICY_FILE,
                        sealed_context=DEFAULT_SEALED_CONTEXT):
    """Seals the secret according to the cotnext and the policy

    This function also clears all of the files created before
    the sealing process, the only remaining file will be the context file
    of the sealed object.

    :param secret: any string that could be sealed to TPM
    :param context: the TPM context file path used for sealing
    :param policy: the TPM plocy file path used for sealing
    :returns: the path to the context file of the sealed object
    :rtype: string
    """
    try:
        with open("/tmp/secret", "w") as file:
            # Write the string to the file
            file.write(secret)
        # utils.execute('echo', secret, '>', '/tmp/secret')
        # utils.execute('tpm2_create', '-C',
        #               '0x81010001', '-L', policy, '-u', '/tmp/key.pub', '-r',
        #               '/tmp/key.priv', '-c', sealed_context,
        #               '--sealing-input', '/tmp/secret')
        # utils.execute('tpm2_create', '-P', 'secret', '-p', 'secret', '-C',
        #               '0x81010001', '-u', '/tmp/key.pub', '-r',
        #               '/tmp/key.priv', '-c', sealed_context,
        #                '--sealing-input', '/tmp/secret')
        utils.execute('tpm2_create', '-P', 'secret', '-p', 'secret', '-C',
                      '0x81010001', '-u', '/tmp/key.pub', '-r',
                      '/tmp/key.priv', '--sealing-input', '/tmp/secret')
        utils.execute('tpm2_load', '-P', 'secret', '-C', '0x81010001', '-u',
                      '/tmp/key.pub', '-r', '/tmp/key.priv', '-c',
                      sealed_context)
    except Exception:
        # (adam) It is considered a failed sealing if the files
        # are not cleared away properly
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Sealing TPM secret has failed!")
    return sealed_context


def _make_sealed_secret_persistent(sealed_context=DEFAULT_SEALED_CONTEXT):
    try:
        utils.execute('tpm2_evictcontrol', '-C', 'o', '-c', sealed_context,
                      '0x81010002')
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Failed to make the sealed context persistent!")


def unseal_tpm_key():
    """This function accesses the TPM key.

    Before the function returns the unsealed object the context file
    used for unsealing will be deleted.

    :param context: TPM context file of the sealed object
    :returns: the tpm secret as a string
    """
    secret_file = "/tmp/secret"
    try:
        # unsealed_secret = utils.execute('tpm2_unseal', '-c', '0x81010002',
        #                                '-p', 'pcr:sha256:0')[0]
        unsealed_secret = utils.execute('tpm2_unseal', '-c', '0x81010002',
                                        '-p', 'secret')[0]
        with open(secret_file, "w") as file:
            # Write the string to the file
            file.write(unsealed_secret)
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Unsealing TPM secret has failed!")
    return secret_file


def check_tpm_compatibility():
    """Checks whether TPM support is available on the host

    :throws Exception TODO:
    """
    return True


def _tpm_credential_exists():
    """Checks whether there is a sealed TPM credential on the expected path

    """
    there_is_credential = False
    try:
        with os.scandir(DEFAULT_WORKDIR) as it:
            for entry in it:
                if entry.name == DEFAULT_SEALED_CTX_NAME:
                    there_is_credential = entry.is_file()
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.debug("DEBUG: no context for sealed TPM credential found!")
    return there_is_credential


def clear_tpm():
    """Clears the full TPM"""
    try:
        utils.execute('tpm2_clear')
    except Exception:
        with excutils.save_and_reraise_exception():
            LOG.error("ERROR: Clearing TPM has failed!")


def generate_tpm_credential():
    """Generates and stores a randomized TPM credential

    Every time this function is called a new TPM credential will be
    generated and it will overwrite the old.
    :returns: the unencrypted TPM credential for use in other processes
    """
    check_tpm_compatibility()
    clear_tpm()
    secret = _generate_tpm_secret()
    primary_context = _create_primary_tpm_context()
    _make_primary_context_persistent()
    policy = _create_tpm_policy()
    _seal_secret_to_tpm(secret, primary_context, policy)
    _make_sealed_secret_persistent()
    secret_file = unseal_tpm_key()
    return secret_file


def check_and_generate_key_file():
    """Checks and generates a key file with TPM

    Checks if there is a TPM context file of a sealed credential at the
    expected location. If the context file is found then the secret will be
    unsealed and returned for further use. In case the TPM context file is not
    present, a new TPM secret will be created and the related context will be
    unsealed and the credential returned as plain text.

    :return: the plain text content of the TPM key file
    :rtype: string
    """
    secret_file = ""
    if _tpm_credential_exists():
        secret_file = unseal_tpm_key()
    else:
        secret_file = generate_tpm_credential()
    return secret_file
